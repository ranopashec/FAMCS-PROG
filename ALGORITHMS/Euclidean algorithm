Один из базовых алгоритмов, используется для нахождения НОД (или НОК) двух (можно и больше) чисел, подробное описание есть в [интернетах](https://en.wikipedia.org/wiki/Euclidean_algorithm), а я начну объяснение сразу в коде:
## Варианты реализации алгоритма Евклида на C++:

### итеративная (через loop) - cамая быстрая реализация алгоритма:

```cpp
int gcd(int a, int b) {
    if (a < b) {
        swap(a, b);
    }

    while (b) {
        a %= b;
        swap(a, b);
    }
    return a;
}
```
Объяснение: 
Меняем местами a и b, чтобы a было больше. Затем прогоняем цикл, в котором находим остаток от деления a на b, записываем его (остаток) в a и меняем a и b местами, до того момента, пока b не станет равным нулю (пока остаток от деления не станет равным нулю). после этого возвращаем а, которое и является НОДом этих двух чисел. Если вы ничего не поняли, не страшно, можете просто забрать документы и идти проходить курсы по figma. Ладно шучу, тут всё просто. Это всего лишь алгоритм нахождения нода, который использовали ещё в древней греции. Вам даже не обязательно знать почему это так работает

Рекурсивно это же можно реализовать так:

```cpp
int gcd(int a, int b) {
    if (a < b) {
        swap(a, b);
    }

    if (b) {
        return gcd(b, a % b);
    } else {
        return a;
    }
}
```

Если  точно a > b: 

```cpp
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
```
## Наименьшее общее кратное

```cpp
int lcm(int a, int b) {
    return a / gcd(a, b) * b; 
}
```
## НОД и НОК для произвольного количества чисел

gcd(a,b,c,d)=gcd(gcd(gcd(a,b),c),d)

lcm(a,b,c,d)=lcm(lcm(lcm(a,b),c),d)
