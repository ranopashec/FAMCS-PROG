# CONTENT:
### Глава 1: Алгоритмы обработки чисел
1. [Поменять местами значения двух переменных](#swap-two-variables)
2. [Алгоритм Евклида](#euclidean-algorithm)
3. [Бинарный Алгоритм Евклида*](#binary-euclidean-algorithm)
4. [Переворачивание целого числа](#reverse-integer)
5. [Повторяемые цифры в числе](#repeated-digits-in-integer)
6. [Нахождение всех делителей натурального числа](#all-devisors)
7. [Проверка числа на простоту](#is-prime)
8. [Нахождение 3-х значных чисел без повторяющихся цифр (без использования операций деления)](#three-digit-numbers-without-repeating-digits)
9. [Вычисление квадратного корня числа по итерационной формуле с заданной точностью](#square-root-with-a-given-accuracy)
10. [Числа Мерсенна](#mersenne-prime)
11. Совершенные числа
12. Дружественные числа
13. Числа Армстронга
14. Числа Смитта
15. Числа Фибоначчи
16. Для заданного натурального числа определить количество
единичных бит в его представлении
17. По заданному натуральному числу ( 4 байта ) получить новое число, переставив младшую цифру исходного числа на место впереди старшей
18. Перевод чисел в различные системы счисления
#### Для доп. изучения:
19. Факторизация(разложение на простые множители)
---
# Глава 1: Алгоритмы обработки чисел
## swap-two-variables 

Поменять местами значения двух переменных - это на столько просто, что даже нельзя назвать алгоритмом. Это скорее функция, которая меняет местами значения переменных, которая даже имеется в стандартной библиотеке -[std::swap](https://en.cppreference.com/w/cpp/algorithm/swap). Реализация функции, которая изменяет отправленные в неё значения перед вашими глазами:

```c++
void swap (int& x, int& y){
  int temp = x;
  x = y;
  y = temp;
}
```
---
## euclidean-algorithm
Алгоритм Евклида - базовый алгоритм нахождения НОД(GCD) (или НОК) двух (можно и больше) чисел:
The Euclidean algorithm is based on the principle that the greatest common divisor of two numbers does not change if the larger number is re- placed by its difference with the smaller number. For example, 21 is the GCD of 252 and 105 (as 252 = 21 × 12 and 105 = 21 × 5), and the same number 21 is also the GCD of 105 and 252 − 105 = 147. Since this replacement reduces the larger of the two numbers, repeating this process gives successively smaller pairs of numbers until the two numbers become equal. - В изначальном виде он назывался “взаимным вычитанием”, так как заключался в поочерёдном вычитании меньшего числа из большего, пока одно из них не станет равным 0. Сегодня чаще всего вместо вычитания используется взятие остатка от деления, но суть алгоритма сохранилась.
### Алгоритм:
Алгоритм заключается в построении ряда чисел следующего вида (a>b): a,b,r1,r2,…,rn, где каждое последующее число является остатком от деления предпредыдущего на предыдущее: r1 = a mod b, r2=b mod r1, … rn = rn−2 mod rn−1. Ряд заканчивается, когда остаток от деления предпоследнего числа на последнее становится равным 0:
rn−1 mod rn = 0. В таком случае утверждается, что: gcd(a,b) = rn
### Доказательство:

Сначала докажем следующее: наборы общих делителей (a,b) и (b,r1) полностью совпадают:
Рассмотрим произвольный (не обязательно наибольший) общий делитель a и b:
t - общий делитель a и b.
r1 = amod b, или a = bq + r1. 
Если потерялись, то q это просто множитель, на который если домножить b и прибавить r1 получится a.

Докажем, что t также является общим делителем b и r1.
b делится на t по определению.
r1 = a − bq =t*( a/t − b/t * q), где a/t и b/t целые по определению.
Значит, r1 также делится на t, чтд

Из того, что все общие делители (a,b) и (b,r1) совпадают, в частности следует, что gcd(a,b) = gcd(b,r1).
Далее по индукции можно доказать следующее:
gcd(a,b) = gcd(b,r1) = gcd(r1,r2) =…= gcd(rn−1,rn) = gcd(rn,0)
(Нуль в последнем выражении появился из условия rn−1 mod rn = 0).
Нуль делится на все числа, отличные от нуля, поэтому справедливо следующее свойство:
gcd(x,0)=x, для любого x∈ℕ.
Следовательно, gcd(a,b) = rn, что и требовалось доказать.

Если вы ничего не поняли, не страшно, можете просто забрать документы и идти проходить курсы по figma. Ладно шучу, тут всё просто. Это всего лишь алгоритм нахождения нода, который использовали ещё в древней греции. Вам даже не обязательно знать почему это так работает, достаточно знать, что это просто работает.

### Варианты реализации на C++ и псевдокоде:

#### итеративная (через loop) - cамая быстрая реализация алгоритма:
```
function gcd(a, b)
    while b ≠ 0
        t := b
        b := a mod b
        a := t
    return a
```
```cpp
int gcd(int a, int b) {
    if (a < b) { // этот кондишн необходим, только если мы не знаем что больше a или b, ведь нам надо, чтобы второе число было меньше.
        swap(a, b);
    }

    while (b) { // реализация отлична от псевдокода так как мы меняем местами переменные в отдельной функции swap, а не в самом цикле
        a %= b;
        swap(a, b);
    }
    return a;
}
```
#### Рекурсивная реализация:

```cpp
int gcd(int a, int b) {
    if (a < b) {
        swap(a, b);
    }

    if (b) {
        return gcd(b, a % b);
    } else {
        return a;
    }
}
```
В сущности своей рекурсия представляет собой тот же loop, только написанный через вызов самой же себя
#### Если точно a > b, то рекурсию можно записать в строчку: 

```cpp
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
```
#### НОК (LCM)

```cpp
int lcm(int a, int b) {
    return a / gcd(a, b) * b; 
}
```
#### НОД и НОК для произвольного количества чисел
`gcd(a,b,c,d)=gcd(gcd(gcd(a,b),c),d)`
`lcm(a,b,c,d)=lcm(lcm(lcm(a,b),c),d)`

---
## binary-euclidean-algorithm
Это не отдельный алгоритм, а просто реализация того, что выше, при помощи [бинарных опираторов](https://www.learncpp.com/cpp-tutorial/bitwise-operators/).
```c++
#include <iostream>
using namespace std;
int main()
{
	setlocale(LC_ALL,".1251");
   	int shift;
   	int x,y,nod;
   	cout << "введите 2 числа\n";
	cin >> x >> y;

	if (x == 0 || y == 0)    // если x или y = 0
		nod = x | y;         // тогда делаем НОД равным числу, неравному 0, по факту просто складываем x и y битовым оператором или ( работает как в ДМиМЛе)
	else
	{ 			             // Иначе мы просто запускаем луп, который делит x и y на 2 до момента пока хотя бы одно из них чётное.
	
		for (shift = 0; ((x | y) & 1) == 0; ++shift)
		{                    // (x | y) ставит единички везде, где они есть хотя бы в одном числе, 1 указывает на второй бит, и в условии проверяется, делится ли хотя бы одно из чисел на 2 без остатка. т.е луп продолжается, пока x или y чётное.
         		x >>= 1;     // деление на 2
         		y >>= 1;     // деление на 2
	 	}

							 // луп, который делит x на 2 пока x чётное.
		while ((x & 1) == 0) 
	    	x >>= 1;     


		do                   // пока y не станет равным нулю
		{
							 // луп, который делит y на 2 пока y чётное.
			while ((y & 1) == 0)
				y >>= 1;     
	    
     // теперь x и y оба нечетны, разность их четная
     
			if (x < y)       // Если x < y, 
				y -= x;      // то делаем y равным y - x
			else
			{                // иначе (если x > y), то  y = x - y
				unsigned int diff = x - y;
		        x = y;
		        y = diff;
		    }
		    
			y >>= 1;         // y / 2 т.к y стало чётным (неч-неч = чётн)
		
		}
		while (y != 0);            


	    nod = x << shift;    // nod равен x умноженному на 2 в степени shift, где shift равна степени двоек в x и y одновременно

}
	cout << "NOD=" << nod;
	return 0;
}
```

---



## reverse-integer
Если число было 1234, то станет 4321
```cpp
int reverse (int num)
{
	int rnum = 0;                    // от reverse_number (перевёрнутое число)
	while (num != 0)
	{            			         // пока число не станет равным нулю мы выполняем:
		rnum = rnum * 10 + num % 10; // перевёрнутое число на каждом этапе цикла становится больше в 10 раз и складывается с остатком от деления изначального числа на 10.
		num /= 10;
	}
	return rnum;
}
```
---

## repeated-digits-in-integer
Найти количество повторений каждой цифры у заданного натурального числа не используя массивов.
```cpp
void repnumcount (int num){
	int tempnum = num, count = 0;
	for (int digit = 0; digit < 10; ++digit){ // пробежим по каждой цифре
	    count = 0;                            // сбросим счётчик повторов
	    num = tempnum;                        // вернём начальному числу его значение 
		while(num > 0){                       // не люблю while-loop но поясню
			if(num % 10 == digit)             // если остаток от деления числа на 10 равен цифре, то 
				count++;                      // увеличиваем счётчик,
			num /=10 ; 	                      // делим число на 10 и
		}                                     // продолжаем пока число не станет равным 0
		if(count!=0)                          // выводим счётчик для каждой цифры
		std::cout << digit << " is mentioned " << count << "times";
}
```
---

## all-devisors
```cpp
void foo (int n){
// d - число на которое проверяется делимость
// е - конец проверки (на середине числа)
	cout << "1" << endl; // 1 является делителем любого натурального числа

	for(int d = 2, int e = n / 2; div <= e ; d++){
	if ( n % d == 0) cout << d << endl;
	}
    
	cout << n << endl;  // само число тоже является своим же делителем
}
```
for-loop который пробегает по всем значениям от 2 до n/2 и проверяет, делит ли d число n нацело.

---

## is-prime
Чтобы проверить, является ли натуральное число x простым, достаточно просто проверить, существует ли в отрезке [2 ; √x] число, на которое делится x. Это достаточно очевидно: если бы существовало такое число y, что x делится на y и √x<y<x, то гарантированно существовало бы и число z=x/y, которое было бы меньше корня, а значит, изначального условия хватило бы для проверки на простоту. Чтобы понять это можно просто подставить числа вместо x и y, например 100 и 20.
```cpp
bool is_prime(int x) {
    for (int i = 2; i <= sqrt(x); i++) {
        if (x % i == 0) {
            return false;
        }
    }

    return true;
}
```
---
## three-digit-numbers-without-repeating-digits
```cpp
void foo{
int i,j,k;
for(i=1;i<=9;i++){
	for(j=0;j<=9;j++){
		for(k=0;k<=9;k++){
			if( (i != j) && (i != k) && (j != k) ) 
			cout << i*100+j*10+k << " ";
			    
		}
	}
}

}
```
---


## square-root-with-a-given-accuracy
xn = x/2 + a/(2 * x) - это просто формула, по которой находится квадратный корень с заданной точностью. Где a - accurtncy (точность) 

```cpp
#include <сmath> // for abs

int aqrt (double num, double acc)
{ 
	double x, xn = num / 2;
	
	do{
		x = xn;
		xn = x/2 + acc/(2 * x);
	}
	while ( abs( xn - x) > acc);

	return x;
}
```
---
## mersenne-prime
```cpp
{//поиск чисел Мерсенна
 int m=10;
 for (int i=1;i<=m;i++)
 {
  int r=1,x=2;
  int n=i;
  while  (n != 0)
  {
    if (n % 2 == 1) r=r*x;
    x=x*x;
    n=n/2;
  }
  r=r-1;
  cout << r << endl;
} }
```
---
