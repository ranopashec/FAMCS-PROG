# content
## [Предысловие](#preface)
## [Глава 1: Понятие асимптотической сложности](#asymptotic-complexity)
## [Глава 2: Алгоритмы обработки чисел |  Алгебра](#number-processing-algorithms)
1. [Поменять местами значения двух переменных](#swap-two-variables)
2. [Алгоритм Евклида | Нахождение НОД и НОК](#euclidean-algorithm)
3. Расширенный алгоритм Евклида
4. [Переворачивание целого числа](#reverse-integer)
5. [Повторяемые цифры в числе](#repeated-digits-in-integer)
6. [Нахождение всех делителей натурального числа](#all-devisors)
7. [Проверка числа на простоту](#is-prime)
8. [Нахождение 3-х значных чисел без повторяющихся цифр (без использования операций деления)](#three-digit-numbers-without-repeating-digits)
9. [Вычисление квадратного корня числа по итерационной формуле с заданной точностью](#square-root-with-a-given-accuracy)
10. [Числа Мерсенна](#mersenne-numbers)
11. [Совершенные числа](#perfect-numbers) 
12. [Дружественные числа](#friend-numbers)
13. Числа Армстронга
14. Числа Смитта
15. Числа Фибоначчи
16. Для заданного натурального числа определить количество
единичных бит в его представлении
17. По заданному натуральному числу ( 4 байта ) получить новое число, переставив младшую цифру исходного числа на место впереди старшей
18. Перевод чисел в различные системы счисления
19. Факторизация(разложение на простые множители)
### [Операции по модулю](#mod)
20. [Бинарное возведение числа в степень](#bin-pow)
21. Вычисление факториала по модулю
---
### preface
Спасибо каждому, кто открыл данную замечательную markdown заметку. Она представляет собой подробный конспект всех изученных автором решений алгоритмических задач: базовых, олимпиадных, собесовых. Задачи разбросаны по заметке врассыпную, структурность есть только в  [оглавлении](#content). Текст заметки подразумевает, что вы подробно ознакомлены с синтаксисом C++ и что-нибудь слышали о математике. Я постараюсь без воды описывать сами алгоритмы. Математические доказательства работы алгоритма при желании можно гуглить, я буду давать лишь описание работы и реализацию на c++ с моим разбором. Ссылки на источники находятся в самом конце заметки. Если у задачи (PROBLEM) не написан алгоритм (ALGORITHM), тогда он либо написан комментариями в реализации (C++ IMPLEMENTATION), либо его работа очевидна и написана в самом условии задачи. Задачи рассортированы по алгоритмам. Основным отличием от подобных сайтов с описанием алгоритмов является объяснение их реализации, а не только её наличие, как на ресурсах, указанных в источниках.

---
### asymptotic-complexity
[link 1](https://brestprog.by/topics/complexity/)
[link 2](https://www.geeksforgeeks.org/types-of-asymptotic-notations-in-complexity-analysis-of-algorithms/)
[link 3](https://en.wikipedia.org/wiki/Big_O_notation)

---
### number-processing-algorithms
(Алгоритмы обработки чисел)
Данные алгоритмы представляют собой скорее обычные задачи, на знание синтаксиса языка, нежели алгоритмы, но всё равно достойны вашего внимания, если вы интересуетесь математикой. Столкнуться с задачами на эти алгоритмы вы можете на первом курсе института, когда только начнёте изучать программирование.
### swap-two-variables 
#### PROBLEM:
Поменять местами значения двух переменных 
#### ALGORITHM:
Это на столько просто, что даже нельзя назвать алгоритмом. Это скорее функция, которая меняет местами значения переменных, которая даже имеется в стандартной библиотеке - [std::swap](https://en.cppreference.com/w/cpp/algorithm/swap). 
#### C++ IMPLEMENTATION:
```c++
void swap (int& x, int& y){ // & - ссылка(reference) на переменную. Необходимо передавать ссылку а не копию, чтобы изменить значение переменных.
  int temp = x;
  x = y;
  y = temp;
}
```
---
### euclidean-algorithm
#### PROBLEM:
Найти НОД(GCD) (или НОК) двух (можно и больше) чисел
#### ALGORITHM:
```The Euclidean algorithm is based on the principle that the greatest common divisor of two numbers does not change if the larger number is replaced by its difference with the smaller number. For example, 21 is the GCD of 252 and 105 (as 252 = 21 × 12 and 105 = 21 × 5), and the same number 21 is also the GCD of 105 and 252 − 105 = 147. Since this replacement reduces the larger of the two numbers, repeating this process gives successively smaller pairs of numbers until the two numbers become equal.``` - В изначальном виде алгоритм назывался “взаимным вычитанием”, так как заключался в поочерёдном вычитании меньшего числа из большего, пока одно из них не станет равным 0. Сегодня чаще всего вместо вычитания используется взятие остатка от деления, но суть алгоритма сохранилась.

Алгоритм заключается в построении ряда чисел следующего вида (a>b): a,b,r1,r2,…,rn, где каждое последующее число является остатком от деления предпредыдущего на предыдущее: r1 = a mod b, r2=b mod r1, … rn = rn−2 mod rn−1. Ряд заканчивается, когда остаток от деления предпоследнего числа на последнее становится равным 0:
rn−1 mod rn = 0. В таком случае утверждается, что: gcd(a,b) = rn

Доказательство:
Сначала докажем следующее: наборы общих делителей (a,b) и (b,r1) полностью совпадают:
Рассмотрим произвольный (не обязательно наибольший) общий делитель a и b:
t - общий делитель a и b.
r1 = amod b, или a = bq + r1. 
Если потерялись, то q это просто множитель, на который если домножить b и прибавить r1 получится a.

Докажем, что t также является общим делителем b и r1.
b делится на t по определению.
r1 = a − bq =t*( a/t − b/t * q), где a/t и b/t целые по определению.
Значит, r1 также делится на t, чтд

Из того, что все общие делители (a,b) и (b,r1) совпадают, в частности следует, что gcd(a,b) = gcd(b,r1).
Далее по индукции можно доказать следующее:
gcd(a,b) = gcd(b,r1) = gcd(r1,r2) =…= gcd(rn−1,rn) = gcd(rn,0)
(Нуль в последнем выражении появился из условия rn−1 mod rn = 0).
Нуль делится на все числа, отличные от нуля, поэтому справедливо следующее свойство:
gcd(x,0)=x, для любого x∈ℕ.
Следовательно, gcd(a,b) = rn, что и требовалось доказать.

Если вы ничего не поняли, не страшно, можете просто забрать документы и идти проходить курсы по figma. Ладно шучу, тут всё просто. Это всего лишь алгоритм нахождения нода, который использовали ещё в древней греции. Вам даже не обязательно знать почему это так работает, достаточно знать, что это просто работает.
#### PSEUDOCODE:
```
function gcd(a, b)
    while b ≠ 0
        t := b
        b := a mod b
        a := t
    return a
```
#### C++ IMPLEMENTATION:
##### итеративная (через loop) - cамая быстрая реализация алгоритма:

```cpp
int gcd(int a, int b) {
    if (a < b) { // этот кондишн необходим, только если мы не знаем что больше a или b, ведь нам надо, чтобы второе число было меньше.
        swap(a, b);
    }

    while (b) { // реализация отлична от псевдокода так как мы меняем местами переменные в отдельной функции swap, а не в самом цикле
        a %= b;
        swap(a, b);
    }
    return a;
}
```
##### Рекурсивная реализация:

```cpp
int gcd(int a, int b) {
    if (a < b) {
        swap(a, b);
    }

    if (b) {
        return gcd(b, a % b);
    } else {
        return a;
    }
}
```
В сущности своей рекурсия представляет собой тот же loop, только написанный через вызов самой же себя
#### Если точно a > b, то рекурсию можно записать в строчку: 

```cpp
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
```
#### НОК (LCM) C++ IMPLEMENTATION:

```cpp
int lcm(int a, int b) {
    return a / gcd(a, b) * b; 
}
```
#### НОД и НОК для произвольного количества чисел

`gcd(a,b,c,d)=gcd(gcd(gcd(a,b),c),d)`
`lcm(a,b,c,d)=lcm(lcm(lcm(a,b),c),d)`
##### реализация при помощи битовых операторов
```cpp
using namespace std; // признак говнокода)
int gcd(int x, int y)
{


	if (x == 0 || y == 0)    // если x или y = 0
		nod = x | y;         // тогда делаем НОД равным числу, неравному 0, по факту просто складываем x и y битовым оператором или ( работает как в ДМиМЛе)
	else
	{ 			             // Иначе мы просто запускаем луп, который делит x и y на 2 до момента пока хотя бы одно из них чётное.
	
		for (shift = 0; ((x | y) & 1) == 0; ++shift)
		{                    // (x | y) ставит единички везде, где они есть хотя бы в одном числе, 1 указывает на второй бит, и в условии проверяется, делится ли хотя бы одно из чисел на 2 без остатка. т.е луп продолжается, пока x или y чётное.
         		x >>= 1;     // деление на 2
         		y >>= 1;     // деление на 2
	 	}

							 // луп, который делит x на 2 пока x чётное.
		while ((x & 1) == 0) 
	    	x >>= 1;     

		do                   // пока y не станет равным нулю
		{
							 // луп, который делит y на 2 пока y чётное.
			while ((y & 1) == 0)
				y >>= 1;     
							 // теперь x и y оба нечетны, разность их четная
							 
			if (x < y)       // Если x < y, 
				y -= x;      // то делаем y равным y - x
			else
			{                // иначе (если x > y), то  y = x - y
				unsigned int diff = x - y;
		        x = y;
		        y = diff;
		    }
		    
			y >>= 1;         // y / 2 т.к y стало чётным (неч-неч = чётн)
		}
		while (y != 0);            

	    nod = x << shift;    // nod равен x умноженному на 2 в степени shift, где shift равна степени двоек в x и y одновременно

}
	return nod;
}
```
#### COMPLEXITY:
##### time: 
O( log(min(a,b)) ) - кол-во операций умножения

---
### reverse-integer
#### PROBLEM:
Перевернуть целое число так что если было 1234, то станет 4321
#### ALGORITHM:
#### C++ IMPLEMENTATION 
```cpp
int reverse (int num)
{
	int rnum = 0;                    // от reverse_number (перевёрнутое число)
	while (num != 0)
	{            			         // пока число не станет равным нулю мы выполняем:
		rnum = rnum * 10 + num % 10; // перевёрнутое число на каждом этапе цикла становится больше в 10 раз и складывается с остатком от деления изначального числа на 10.
		num /= 10;
	}
	return rnum;
}
```
---
### repeated-digits-in-integer
#### PROBLEM:
Найти количество повторений каждой цифры у заданного натурального числа не используя массивов.
#### ALGORITHM:
#### C++ IMPLEMENTATION:
```cpp
void repnumcount (int num){
	int tempnum = num, count = 0;
	for (int digit = 0; digit < 10; ++digit){ // пробежим по каждой цифре
	    count = 0;                            // сбросим счётчик повторов
	    num = tempnum;                        // вернём начальному числу его значение 
		while(num > 0){                       // не люблю while-loop но поясню
			if(num % 10 == digit)             // если остаток от деления числа на 10 равен цифре, то 
				count++;                      // увеличиваем счётчик,
			num /=10 ; 	                      // делим число на 10 и
		}                                     // продолжаем пока число не станет равным 0
		if(count!=0)                          // выводим счётчик для каждой цифры
		std::cout << digit << " is mentioned " << count << "times";
}
```
---
### all-devisors
#### PROBLEM:
Найти все натуральные делители целого числа
#### ALGORITHM:
Loop который пробегает по всем значениям от 2 до n/2 и проверяет, делит ли d число n нацело.
#### C++ IMPLEMENTATION 
```cpp
void foo (int n){
// d - число на которое проверяется делимость
// е - конец проверки (на середине числа)
	cout << "1" << endl; // 1 является делителем любого натурального числа

	for(int d = 2, int e = n / 2; div <= e ; d++){
	if ( n % d == 0) cout << d << endl;
	}
    
	cout << n << endl;  // само число тоже является своим же делителем
}
```

---
### is-prime
#### PROBLEM:
Создать алгоритм проверки натурального числа на простоту
#### ALGORITHM:
Чтобы проверить, является ли натуральное число x простым, достаточно просто проверить, существует ли в отрезке [2 ; √x] число, на которое делится x. Это достаточно очевидно: если бы существовало такое число y, что x делится на y и √x<y<x, то гарантированно существовало бы и число z=x/y, которое было бы меньше корня, а значит, изначального условия хватило бы для проверки на простоту. Чтобы понять это можно просто подставить числа вместо x и y, например 100 и 20.
#### C++ IMPLEMENTATION:
```cpp
bool is_prime(int x) {
    for (int i = 2; i <= sqrt(x); i++) {
        if (x % i == 0) {
            return false;
        }
    }

    return true;
}
```
---
### three-digit-numbers-without-repeating-digits
#### PROBLEM:
Написать алгоритм нахождения всех трёхзначных чисел, не имеющих повторяющихся чисел
#### ALGORITHM:
Всё очень просто. Для каждого числа сотен, десятков и единиц находим число, где сотни не равны десяткам, десятки единицам и единицы сотням.
#### C++ IMPLEMENTATION 
```cpp
void foo{
int hundreds, dozens, units;
for(hundreds=1;hundreds<=9;hundreds++){
	for(dozens=0;dozens<=9;dozens++){
		for(units=0;units<=9;units++){
			if( (hundreds != dozens) && (hundreds != units) && (dozens != units) ) 
			cout << hundreds*100 + dozens*10 + units << " ";
			    
		}
	}
}

}
```
---
### square-root-with-a-given-accuracy
#### PROBLEM:
Найти квадратный корень числа с заданной точностью
#### ALGORITHM:
xn = x/2 + a/(2 * x) - это просто формула, по которой находится квадратный корень с заданной точностью. Где a - accurtncy (точность) 
#### C++ IMPLEMENTATION: 

```cpp
#include <сmath> // for abs

int asqrt (double num, double acc)
{ 
	double x, xn = num / 2;
	
	do{
		x = xn;
		xn = x/2 + acc/(2 * x);
	}
	while ( abs( xn - x) > acc);

	return x;
}
```
---
### mersenne-numbers
#### PROBLEM:
Найти первые n [чисeл Мерсенна](https://www.youtube.com/watch?v=Zdqur0Cstbg)
#### ALGORITHM:
#### C++ IMPLEMENTATION
```cpp
int mersenne (int n){
	for ( int i; i <= n; i++)
		std::cout << pow(2, i) -1;
}
```
---
### perfect-numbers
#### PROBLEM:
1) Найти все [совершенные числа](https://www.youtube.com/watch?v=GuoAz5OMon8) меньше какого-то числа
2) Найти первые n совершенных чисел.
#### ALGORITHM:
bruteforce
#### C++ IMPLEMENTATION:
1) Выводит все совершенные числа, не превышающие n
```cpp
void perfectNumbers (uint64_t n)
{
	uint64_t sum = 1;
	for (uint64_t i = 6; i <= n; i++) // пробегаем по всем числам от i до n
	{
		sum = 1 ;
		for (uint64_t div = 2; div*div <= i; div++) // div от divisor(делитель)
		{
			if (i % div == 0) // если число является делителем
				sum = sum + div + (i / div); // суммируем его с предыдущими делителями
		}
		if (i == sum ) // если сумма делителей числа равна самому числу,
			std::cout << i << '\n'; //  то мы нашли то, что искали
	}
}
```
2) Выводит первых n совершенных чисел
```cpp
void perfectNumbers (int n)

{
	int c = 0; // счётчик найденных совершенных чисел
	for (uint64_t i = 6;c < n;i+=2) // пробегаем по всем числам от i до n
	{
		uint64_t sum = 1;
		for (uint64_t div = 2; div*div <= i; div++) // div от divisor(делитель)
		{
			if (i % div == 0) // если число является делителем
			sum = sum + div + (i / div); // суммируем его с предыдущими делителями
		}
		// если сумма делителей числа равна самому числу, то мы нашли совершенное число
		if (i == sum )
		{
			std::cout << i << "\n";
			c++;
		}
	} 
}
```

### friend-numbers
#### PROBLEM:
1) Найти все пары дружественных чисел, меньше числа n. 
2) Найти первые n пар дружественных чисел
#### ALGORITHM:
Дружественные - это такие два числа, каждое из которых равно сумме делителей второго. Наименьшие из дружественных чисел 220 и 284.
Воспользуемся обычным bruteforce с вложенным циклом (nested loop или цикл в цикле). Делители чисел найдём так же через цикл, как в предыдущей задаче.
#### C++ IMPLEMENTATION:
1)
```cpp
void friendNums(int64_t n)
{
	int64_t sum = 1;
	for (int64_t i1 = 220 ; i1 <= n; i1++) // пробегаем по всем числам от i до n
	{
		sum = 1 ;
		for (int64_t div = 2; div*div <= i1; div++) // div от divisor(делитель)
		{
			if (i1 % div == 0) // если число является делителем
				sum = sum + div + (i1 / div); // суммируем его с предыдущими делителями
		}
		
		int64_t i2 = i1; // добавляем счётчике для второго числа
		
		while (i2 <= n) 
		{
			++i2;
			if (i2 == sum) // среди чисел i2 > i1 находим то, которое равно сумме делителей числа i1
			{
				sum = 1 ; // аналогично суммируем его делители
				for (int64_t div = 2; div*div <= i2; div++) 
				{
					if (i2 % div == 0) 
						sum = sum + div + (i2 / div);
				}
				
				if (i1 == sum) // если i1 равно сумме делителей i2, то мы нашли нашего друга
				std::cout << i1 << " & " << i2 << '\n';
				
				break; // прерываем цикл while, цикл for продолжает поиск до n
			}
		}
	}
}
/* Можно использовать uint64_t или любой другой int в зависимости от размеров n. Чем больше int, тем дольше работает программа (использует больше памяти).
```
2) Распишу позже, но если кому нужна подсказка, то делаем всё аналогично [совершенным числам](#perfect-numbers)
### armstrong-numbers
### smith-numbers
### fibonacci-numbers
### mod
Остаток от деления числа a на m:
a mod m = a % m 
Свойства;
(a + b) mod m = ((a mod m) + (b mod m)) mod m;
(a − b) modm = ((a mod m) −(b mod m)) mod m;
(ab) mod m = ((a mod m) ∗ (b mod m)) mod m;
При желании доказательства всех свойств можно обнаружить в интернете.
### bin-pow
#### PROBLEM:
Возвести число a в степень n и вернуть остаток от деления результата на c. Количество операций должно быть равно log(b);
#### ALGORITHM:
Для чётного n верно: a^n = a^(n/2) * a^(n/2)
Для нечётного: a^n = a * a^(n-1).
Получаем рекурсивную формулу реализованную ниже, работающую за O(log n)
#### C++ IMPLEMENTATION:
##### Рекурсивная:
```cpp
int binpow (uint64_t a, uint64_t n, uint64_t c) {
	if (n == 0) 
		return 1;
	if (n % 2 == 1)
		return binpow (a, n-1, c) * a % c;
	else {
		uint64_t b = binpow (a, n/2, c);
		return b * b % c;
	}
}
```
##### Нерекурсивная:
```cpp
int BinPow (uint64_t a, uint64_t  b, uint64_t c )  
    uint64_t res = 1;  
    while (b){  
        if (b & 1) {  
            res *= a;  
            res %=c;  
            --b;  
        }  
        else {  
             a *= a;  
             a %= c;  
             b >>= 1;  
        }  
        }  
    return res;
```
