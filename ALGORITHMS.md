# CONTENT:
### Глава 1: Алгоритмы обработки чисел
1. [Поменять местами значения двух переменных](#swap-two-variables)
2. [Алгоритм Евклида](#euclidean-algorithm)
3. [Бинарный Алгоритм Евклида*](#binary-euclidean-algorithm)
4. [Переворачивание целого числа](#reverse-integer)
5. [Повторяемые цифры в числе](#repeated-digits-in-integer)
6. [Нахождение всех делителей натурального числа](#all-devisors)
7. [Проверка числа на простоту](#is-prime)
8. [Нахождение 3-х значных чисел без повторяющихся цифр (без использования операций деления)](#three-digit-numbers-without-repeating-digits)
9. [Вычисление квадратного корня числа по итерационной формуле с заданной точностью](#square-root-with-a-given-accuracy)
10. [Совершенные числа](#perfect-numbers)
11. Дружественные числа
12. Числа Армстронга
13. Числа Смитта
14. Числа Фибоначчи
15. Для заданного натурального числа определить количество
единичных бит в его представлении
17. По заданному натуральному числу ( 4 байта ) получить новое число, переставив младшую цифру исходного числа на место впереди старшей
18. Перевод чисел в различные системы счисления
#### Для доп. изучения:
19. Факторизация(разложение на простые множители)
---
# Глава 1: Алгоритмы обработки чисел
## swap-two-variables 
- problem
Поменять местами значения двух переменных 
- algorithm 
Это на столько просто, что даже нельзя назвать алгоритмом. Это скорее функция, которая меняет местами значения переменных, которая даже имеется в стандартной библиотеке - [std::swap](https://en.cppreference.com/w/cpp/algorithm/swap). 
- c++ implementation

```c++
void swap (int& x, int& y){
  int temp = x;
  x = y;
  y = temp;
}
```
---
## euclidean-algorithm
- problem

Найти НОД(GCD) (или НОК) двух (можно и больше) чисел

- algorithm

The Euclidean algorithm is based on the principle that the greatest common divisor of two numbers does not change if the larger number is replaced by its difference with the smaller number. For example, 21 is the GCD of 252 and 105 (as 252 = 21 × 12 and 105 = 21 × 5), and the same number 21 is also the GCD of 105 and 252 − 105 = 147. Since this replacement reduces the larger of the two numbers, repeating this process gives successively smaller pairs of numbers until the two numbers become equal. - В изначальном виде он назывался “взаимным вычитанием”, так как заключался в поочерёдном вычитании меньшего числа из большего, пока одно из них не станет равным 0. Сегодня чаще всего вместо вычитания используется взятие остатка от деления, но суть алгоритма сохранилась.

Алгоритм заключается в построении ряда чисел следующего вида (a>b): a,b,r1,r2,…,rn, где каждое последующее число является остатком от деления предпредыдущего на предыдущее: r1 = a mod b, r2=b mod r1, … rn = rn−2 mod rn−1. Ряд заканчивается, когда остаток от деления предпоследнего числа на последнее становится равным 0:
rn−1 mod rn = 0. В таком случае утверждается, что: gcd(a,b) = rn

Доказательство:
Сначала докажем следующее: наборы общих делителей (a,b) и (b,r1) полностью совпадают:
Рассмотрим произвольный (не обязательно наибольший) общий делитель a и b:
t - общий делитель a и b.
r1 = amod b, или a = bq + r1. 
Если потерялись, то q это просто множитель, на который если домножить b и прибавить r1 получится a.

Докажем, что t также является общим делителем b и r1.
b делится на t по определению.
r1 = a − bq =t*( a/t − b/t * q), где a/t и b/t целые по определению.
Значит, r1 также делится на t, чтд

Из того, что все общие делители (a,b) и (b,r1) совпадают, в частности следует, что gcd(a,b) = gcd(b,r1).
Далее по индукции можно доказать следующее:
gcd(a,b) = gcd(b,r1) = gcd(r1,r2) =…= gcd(rn−1,rn) = gcd(rn,0)
(Нуль в последнем выражении появился из условия rn−1 mod rn = 0).
Нуль делится на все числа, отличные от нуля, поэтому справедливо следующее свойство:
gcd(x,0)=x, для любого x∈ℕ.
Следовательно, gcd(a,b) = rn, что и требовалось доказать.

Если вы ничего не поняли, не страшно, можете просто забрать документы и идти проходить курсы по figma. Ладно шучу, тут всё просто. Это всего лишь алгоритм нахождения нода, который использовали ещё в древней греции. Вам даже не обязательно знать почему это так работает, достаточно знать, что это просто работает.
- c++ and pseudocode implementation 

итеративная (через loop) - cамая быстрая реализация алгоритма:
```
function gcd(a, b)
    while b ≠ 0
        t := b
        b := a mod b
        a := t
    return a
```
```cpp
int gcd(int a, int b) {
    if (a < b) { // этот кондишн необходим, только если мы не знаем что больше a или b, ведь нам надо, чтобы второе число было меньше.
        swap(a, b);
    }

    while (b) { // реализация отлична от псевдокода так как мы меняем местами переменные в отдельной функции swap, а не в самом цикле
        a %= b;
        swap(a, b);
    }
    return a;
}
```
Рекурсивная реализация:

```cpp
int gcd(int a, int b) {
    if (a < b) {
        swap(a, b);
    }

    if (b) {
        return gcd(b, a % b);
    } else {
        return a;
    }
}
```
В сущности своей рекурсия представляет собой тот же loop, только написанный через вызов самой же себя
#### Если точно a > b, то рекурсию можно записать в строчку: 

```cpp
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
```
- НОК (LCM) c++ implementation 

```cpp
int lcm(int a, int b) {
    return a / gcd(a, b) * b; 
}
```
- НОД и НОК для произвольного количества чисел

`gcd(a,b,c,d)=gcd(gcd(gcd(a,b),c),d)`
`lcm(a,b,c,d)=lcm(lcm(lcm(a,b),c),d)`

---
## binary-euclidean-algorithm
- problem

Написать алгоритм Евклида при помощи [бинарных опираторов](https://www.learncpp.com/cpp-tutorial/bitwise-operators/)

- c++ implementation 
```c++
#include <iostream>
using namespace std;
int main()
{
	setlocale(LC_ALL,".1251");
   	int shift;
   	int x,y,nod;
   	cout << "введите 2 числа\n";
	cin >> x >> y;

	if (x == 0 || y == 0)    // если x или y = 0
		nod = x | y;         // тогда делаем НОД равным числу, неравному 0, по факту просто складываем x и y битовым оператором или ( работает как в ДМиМЛе)
	else
	{ 			             // Иначе мы просто запускаем луп, который делит x и y на 2 до момента пока хотя бы одно из них чётное.
	
		for (shift = 0; ((x | y) & 1) == 0; ++shift)
		{                    // (x | y) ставит единички везде, где они есть хотя бы в одном числе, 1 указывает на второй бит, и в условии проверяется, делится ли хотя бы одно из чисел на 2 без остатка. т.е луп продолжается, пока x или y чётное.
         		x >>= 1;     // деление на 2
         		y >>= 1;     // деление на 2
	 	}

							 // луп, который делит x на 2 пока x чётное.
		while ((x & 1) == 0) 
	    	x >>= 1;     


		do                   // пока y не станет равным нулю
		{
							 // луп, который делит y на 2 пока y чётное.
			while ((y & 1) == 0)
				y >>= 1;     
	    
     // теперь x и y оба нечетны, разность их четная
     
			if (x < y)       // Если x < y, 
				y -= x;      // то делаем y равным y - x
			else
			{                // иначе (если x > y), то  y = x - y
				unsigned int diff = x - y;
		        x = y;
		        y = diff;
		    }
		    
			y >>= 1;         // y / 2 т.к y стало чётным (неч-неч = чётн)
		
		}
		while (y != 0);            


	    nod = x << shift;    // nod равен x умноженному на 2 в степени shift, где shift равна степени двоек в x и y одновременно

}
	cout << "NOD=" << nod;
	return 0;
}
```

---
## reverse-integer
- problem

Перевернуть целое число так что если было 1234, то станет 4321

- algorithm -
- c++ implementation 
```cpp
int reverse (int num)
{
	int rnum = 0;                    // от reverse_number (перевёрнутое число)
	while (num != 0)
	{            			         // пока число не станет равным нулю мы выполняем:
		rnum = rnum * 10 + num % 10; // перевёрнутое число на каждом этапе цикла становится больше в 10 раз и складывается с остатком от деления изначального числа на 10.
		num /= 10;
	}
	return rnum;
}
```
---
## repeated-digits-in-integer
- problem
Найти количество повторений каждой цифры у заданного натурального числа не используя массивов.
- algorithm-
- c++ implementation
```cpp
void repnumcount (int num){
	int tempnum = num, count = 0;
	for (int digit = 0; digit < 10; ++digit){ // пробежим по каждой цифре
	    count = 0;                            // сбросим счётчик повторов
	    num = tempnum;                        // вернём начальному числу его значение 
		while(num > 0){                       // не люблю while-loop но поясню
			if(num % 10 == digit)             // если остаток от деления числа на 10 равен цифре, то 
				count++;                      // увеличиваем счётчик,
			num /=10 ; 	                      // делим число на 10 и
		}                                     // продолжаем пока число не станет равным 0
		if(count!=0)                          // выводим счётчик для каждой цифры
		std::cout << digit << " is mentioned " << count << "times";
}
```
---
## all-devisors
- problem

Найти все натуральные делители целого числа

- algorithm

Loop который пробегает по всем значениям от 2 до n/2 и проверяет, делит ли d число n нацело.

- c++ implementation 
```cpp
void foo (int n){
// d - число на которое проверяется делимость
// е - конец проверки (на середине числа)
	cout << "1" << endl; // 1 является делителем любого натурального числа

	for(int d = 2, int e = n / 2; div <= e ; d++){
	if ( n % d == 0) cout << d << endl;
	}
    
	cout << n << endl;  // само число тоже является своим же делителем
}
```


---
## is-prime
- problem

Создать алгоритм проверки натурального числа на простоту

- algorithm 

Чтобы проверить, является ли натуральное число x простым, достаточно просто проверить, существует ли в отрезке [2 ; √x] число, на которое делится x. Это достаточно очевидно: если бы существовало такое число y, что x делится на y и √x<y<x, то гарантированно существовало бы и число z=x/y, которое было бы меньше корня, а значит, изначального условия хватило бы для проверки на простоту. Чтобы понять это можно просто подставить числа вместо x и y, например 100 и 20.
- c++ implementation
```cpp
bool is_prime(int x) {
    for (int i = 2; i <= sqrt(x); i++) {
        if (x % i == 0) {
            return false;
        }
    }

    return true;
}
```
---
## three-digit-numbers-without-repeating-digits
- problem

Написать алгоритм нахождения всех трёхзначных чисел, не имеющих повторяющихся чисел

- algorithm 

Всё очень просто. Для каждого числа сотен, десятков и единиц находим число, где сотни не равны десяткам, десятки единицам и единицы сотням.
- c++ implementation 
```cpp
void foo{
int hundreds, dozens, units;
for(hundreds=1;hundreds<=9;hundreds++){
	for(dozens=0;dozens<=9;dozens++){
		for(units=0;units<=9;units++){
			if( (hundreds != dozens) && (hundreds != units) && (dozens != units) ) 
			cout << hundreds*100 + dozens*10 + units << " ";
			    
		}
	}
}

}
```
---


## square-root-with-a-given-accuracy
- problem

Найти квадратный корень числа с заданной точностью
- algorithm 

xn = x/2 + a/(2 * x) - это просто формула, по которой находится квадратный корень с заданной точностью. Где a - accurtncy (точность) 
- c++ implementation 

```cpp
#include <сmath> // for abs

int aqrt (double num, double acc)
{ 
	double x, xn = num / 2;
	
	do{
		x = xn;
		xn = x/2 + acc/(2 * x);
	}
	while ( abs( xn - x) > acc);

	return x;
}
```
---
## perfect-numbers
- problem

Найти все [совершенные числа](https://www.youtube.com/watch?v=GuoAz5OMon8) меньше какого-то числа
Найти первые n совершенных чисел. 
Проверить число на совершенность.

- algorithm 

just bruteforce
- c++ implementation
Выводит все совершенные числа, не превышающие n.
```cpp
void perfectNumbers (int n) 
{
	int sum = 1;
	for (int i = 3; i <= n; i++) // пробегаем по всем числам от i до n
	{

	    sum = 1 ;
	    for (int div = 2; div <= i / 2 ; d++) // div от divisor(делитель)
	    
	        if (i % div == 0)                // если число является делителем
		        sum = sum + div;             // суммируем его с предыдущими делителями

	    if (i == sum )                       // если сумма делителей числа равна самому числу, то мы нащли то, что искали.
	        std::cout << i << '\n';
	}
}
```

Выводит первых n совершенных чисел
```cpp
#include <iostream>

using namespace std;

int main (){// первых n совершенных чисел

int n,p,i,flag,ch;

n=6;

p=2;i=1;

while (i<=n)

{

//простое или нет

int j=2;

flag=1; //да

while ((j<=p/2) && (flag))

if ( !(p%j))

flag=0; //нет

else ++j;

if ((flag)||(p==2)||(p==3))

{

// ch=step(2,p-1)*(step(2,p)-1);

int step=1;

int m=p-1;

int x=2;

while (m != 0)

{

if (m % 2 == 1) step=step*x;

x=x*x;

m=m / 2;

}

ch=step*(step*2-1);

cout << ch << endl;

i++;

}

p++; }

return 0; }
```
Я МАНАЛ ЭТО ДЕКОДИТЬ
