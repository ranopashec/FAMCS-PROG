{
	"nodes":[
		{"type":"text","text":"**operator overloading**","id":"97b22b9a51a2919e","x":-179,"y":-119,"width":250,"height":60,"color":"6"},
		{"type":"text","text":"Using function overloading to overload operators","id":"f7ed24461a77ca7a","x":100,"y":-119,"width":250,"height":60},
		{"type":"text","text":"Rules, used by compiler, when evaluating an expression containing an operator:","id":"dafcdf1957119d3e","x":100,"y":0,"width":369,"height":73},
		{"type":"text","text":"**limitations on operator overloading**","id":"7abec560d938fc5d","x":-548,"y":0,"width":369,"height":73},
		{"type":"text","text":"If all of the operands are fundamental data types, the compiler will call a built-in routine if one exists. If one does not exist, the compiler will produce a compiler error.","id":"01791092d431cfc4","x":640,"y":-107,"width":660,"height":97,"color":"4"},
		{"type":"text","text":"If _any_ of the operands are program-defined types, the compiler will use the [function overload resolution algorithm](https://www.learncpp.com/cpp-tutorial/function-overload-resolution-and-ambiguous-matches/) to see if it can find an overloaded operator that is an unambiguous best match. This may involve implicitly converting one or more operands to match the parameter types of an overloaded operator. It may also involve implicitly converting program-defined types into fundamental types (via an overloaded typecast) so that it can match a built-in operator. If no match can be found (or an ambiguous match is found), the compiler will error.","id":"d239e2b4cae28244","x":640,"y":-8,"width":660,"height":208,"color":"4"},
		{"type":"text","text":"conditional `?:`, sizeof, scope `::`, member selector `.`, pointer member selector `*`, typeid, and the casting operators CAN'T be overloaded.","id":"f12f5446317af96f","x":-1360,"y":-261,"width":582,"height":79,"color":"4"},
		{"type":"text","text":"you can only overload the operators that exist. You can not create new operators or rename existing operators","id":"a5e5f49f1bab64c9","x":-1360,"y":-142,"width":582,"height":89,"color":"4"},
		{"type":"text","text":"at least one of the operands in an overloaded operator must be a user-defined type. This means you could overload `operator+(int, Mystring)`, but not `operator+(int, double)`","id":"732817837f00af83","x":-1360,"y":-13,"width":582,"height":99,"color":"4"},
		{"type":"text","text":" it is not possible to change the number of operands an operator supports","id":"ca7ea9a1ffb21bf9","x":-1360,"y":126,"width":582,"height":60,"color":"4"},
		{"type":"text","text":"all operators keep their default precedence and associativity (regardless of what they’re used for) and this can not be changed.","id":"d9c026d9b81c44b3","x":-1360,"y":226,"width":582,"height":80,"color":"4"},
		{"type":"text","text":"### using friend functions","id":"57ae7870b454b5c0","x":-884,"y":514,"width":276,"height":50,"color":"5"},
		{"type":"text","text":"```cpp\n#include <iostream>\n\nclass Cents\n{ \n\tint m_cents {};\n\tpublic:\n\t\tCents(int cents) : m_cents{ cents } { }\n\t\t// add Cents + Cents using a friend function\n\t\tfriend Cents operator+(const Cents& c1, const Cents& c2);\n\t\t\n\t\tint getCents() const { return m_cents; } \n};\n// note: this function is not a member function!\nCents operator+(const Cents& c1, const Cents& c2)\n{\n\t// use the Cents constructor and operator+(int, int)\n\t// we can access m_cents directly because this is a friend function\n\treturn c1.m_cents + c2.m_cents;\n}\n\nint main()\n{\n\tCents cents1{ 6 }; Cents cents2{ 8 };\n\tCents centsSum{ cents1 + cents2 };\n\tstd::cout << \"I have \" << centsSum.getCents() << \" cents.\\n\";\n}\n```","id":"d36f9f4374e62c90","x":-1106,"y":602,"width":720,"height":678},
		{"type":"text","text":"```cpp\n// note: this function is not a member function nor a friend function!\nCents operator+(const Cents& c1, const Cents& c2)\n{\n  // use the Cents constructor and operator+(int, int)\n  // we don't need direct access to private members here\n  return Cents{ c1.getCents() + c2.getCents() };\n}\n```","id":"3ba6da8c16532ca6","x":-347,"y":768,"width":589,"height":248},
		{"type":"text","text":"Prefer overloading operators as normal functions instead of friends if it’s possible to do so without adding additional functions.","id":"7fa8180929768602","x":-327,"y":1299,"width":549,"height":80,"color":"4"},
		{"type":"text","text":"- If you’re overloading a binary operator that does not modify its left operand (e.g. operator+), do so as a normal function (preferred) or friend function.\n- If you’re overloading a binary operator that modifies its left operand, but you can’t add members to the class definition of the left operand (e.g. operator<<, which has a left operand of type ostream), do so as a normal function (preferred) or friend function.","id":"ad26f1daf2df2f2a","x":-405,"y":1399,"width":706,"height":177,"color":"4"},
		{"type":"text","text":"### using normal functions","id":"4de415e54b7b7d33","x":-206,"y":489,"width":303,"height":50,"color":"5"},
		{"type":"text","text":"```cpp\n#include <iostream>\n\nclass Cents\n{\nprivate:\n    int m_cents {};\n\npublic:\n    Cents(int cents)\n        : m_cents { cents } { }\n\n    // Overload Cents + int\n    Cents operator+ (int value);\n\n    int getCents() const { return m_cents; }\n};\n// note: this function is a member function!\n// the cents parameter in the friend version is now the implicit *this parameter\nCents Cents::operator+ (int value)\n{\n    return Cents { m_cents + value };\n}\n\nint main()\n{\n\tCents cents1 { 6 };\n\tCents cents2 { cents1 + 2 };\n\tstd::cout << \"I have \" << cents2.getCents() << \" cents.\\n\";\n\n\treturn 0;\n}\n```","id":"11781018a001f667","x":294,"y":602,"width":825,"height":737},
		{"type":"text","text":"- If you’re overloading assignment (=), subscript ([]), function call (()), or member selection (->), do so as a member function.\n- If you’re overloading a unary operator, do so as a member function.\n- If you’re overloading a binary operator that modifies its left operand (e.g. operator+=), and you can modify the definition of the left operand, do so as a member function.","id":"4deeebba46ad8d6c","x":328,"y":1399,"width":758,"height":177,"color":"4"},
		{"type":"text","text":"### using member functions","id":"73099defc6dcb554","x":546,"y":489,"width":320,"height":50,"color":"5"},
		{"type":"text","text":"### ways to overload operators ","id":"4d4a47884473024a","x":-229,"y":136,"width":350,"height":50,"color":"6"},
		{"type":"text","text":"```cpp\nclass Cents\n{\nprivate:\n    int m_cents {};\n\npublic:\n    Cents(int cents): m_cents{cents} {}\n\n    // Overload -Cents as a member function\n    Cents operator-() const;\n\n    int getCents() const { return m_cents; }\n};\n\n// note: this function is a member function!\nCents Cents::operator-() const\n{\n    return -m_cents; // since return type is a Cents, this does an implicit conversion from int to Cents using the Cents(int) constructor\n}\n```","id":"083ed5f9817ca9eb","x":470,"y":1920,"width":474,"height":640},
		{"type":"text","text":"### Overloading unary operators +, -, and !","id":"9023d77bf3e9d372","x":475,"y":1800,"width":465,"height":50,"color":"5"},
		{"type":"text","text":"### Overloading the increment and decrement operators","id":"530c9e68b5d833aa","x":1119,"y":1800,"width":620,"height":50,"color":"5"},
		{"type":"text","text":"Prefix increment and decrement are overloaded exactly the same as any normal unary operator.","id":"d0a23722dc15858e","x":1214,"y":2139,"width":430,"height":75},
		{"type":"text","text":"If the overloaded operator has an int parameter, the operator is a postfix overload. If the overloaded operator has no parameter, the operator is a prefix overload.","id":"b54a816907f36332","x":1198,"y":2269,"width":463,"height":98,"color":"4"},
		{"type":"text","text":"### Overloading the comparison operators","id":"c7450d3a99642dd5","x":-1227,"y":1800,"width":480,"height":50,"color":"5"},
		{"type":"text","text":"### Overloading operators `<<` and `>>`","id":"1bf3e677510ed023","x":-285,"y":1800,"width":465,"height":50,"color":"5"},
		{"type":"text","text":"```cpp\n#include <iostream>\n\nclass Point\n{\nprivate:\n    double m_x{};\n    double m_y{};\n    double m_z{};\n\npublic:\n    Point(double x=0.0, double y=0.0, double z=0.0)\n      : m_x{x}, m_y{y}, m_z{z}\n    {\n    }\n\n    friend std::ostream& operator<< (std::ostream& out, const Point& point);\n    friend std::istream& operator>> (std::istream& in, Point& point);\n};\n\nstd::ostream& operator<< (std::ostream& out, const Point& point)\n{\n    // Since operator<< is a friend of the Point class, we can access Point's members directly.\n    out << \"Point(\" << point.m_x << \", \" << point.m_y << \", \" << point.m_z << ')';\n\n    return out;\n}\n\nstd::istream& operator>> (std::istream& in, Point& point)\n{\n    // Since operator>> is a friend of the Point class, we can access Point's members directly.\n    // note that parameter point must be non-const so we can modify the class members with the input values\n    in >> point.m_x;\n    in >> point.m_y;\n    in >> point.m_z;\n\n    return in;\n}\n```","id":"88381d6939418f2e","x":-512,"y":1920,"width":919,"height":893},
		{"type":"text","text":"TIP:\n- operator!= can be implemented as !(operator==)\n- operator> can be implemented as operator< with the order of the parameters flipped\n- operator>= can be implemented as !(operator<)\n- operator<= can be implemented as !(operator>)","id":"bdbc5b6b2f0a123f","x":-2165,"y":1714,"width":631,"height":222,"color":"3"},
		{"type":"text","text":"```cpp\n#include <iostream>\n\nclass Cents\n{\nprivate:\n    int m_cents;\n\npublic:\n    Cents(int cents)\n\t: m_cents{ cents }\n\t{}\n\n    friend bool operator== (const Cents& c1, const Cents& c2);\n    friend bool operator!= (const Cents& c1, const Cents& c2);\n\n    friend bool operator< (const Cents& c1, const Cents& c2);\n    friend bool operator> (const Cents& c1, const Cents& c2);\n\n    friend bool operator<= (const Cents& c1, const Cents& c2);\n    friend bool operator>= (const Cents& c1, const Cents& c2);\n};\n\nbool operator== (const Cents& c1, const Cents& c2)\n{\n    return c1.m_cents == c2.m_cents;\n}\n\nbool operator!= (const Cents& c1, const Cents& c2)\n{\n    return c1.m_cents != c2.m_cents;\n}\n\nbool operator> (const Cents& c1, const Cents& c2)\n{\n    return c1.m_cents > c2.m_cents;\n}\n\nbool operator< (const Cents& c1, const Cents& c2)\n{\n    return c1.m_cents < c2.m_cents;\n}\n\nbool operator<= (const Cents& c1, const Cents& c2)\n{\n    return c1.m_cents <= c2.m_cents;\n}\n\nbool operator>= (const Cents& c1, const Cents& c2)\n{\n    return c1.m_cents >= c2.m_cents;\n}\n\n```","id":"e1817b7cc4de2984","x":-1347,"y":1920,"width":720,"height":1160},
		{"type":"text","text":"```cpp\n#include <iostream>\n\nclass Cents\n{\nprivate:\n    int m_cents;\n\npublic:\n    Cents(int cents)\n        : m_cents{ cents }\n    {}\n\n    friend bool operator== (const Cents& c1, const Cents& c2) { return c1.m_cents == c2.m_cents; };\n    friend bool operator!= (const Cents& c1, const Cents& c2) { return !(operator==(c1, c2)); };\n\n    friend bool operator< (const Cents& c1, const Cents& c2) { return c1.m_cents < c2.m_cents; };\n    friend bool operator> (const Cents& c1, const Cents& c2) { return operator<(c2, c1); };\n\n    friend bool operator<= (const Cents& c1, const Cents& c2) { return !(operator>(c1, c2)); };\n    friend bool operator>= (const Cents& c1, const Cents& c2) { return !(operator<(c1, c2)); };\n\n};\n```","id":"a48a27d429b249f6","x":-2320,"y":2000,"width":942,"height":620},
		{"type":"text","text":"```cpp\nclass IntList\n{\nprivate:\n    int m_list[10]{};\n\npublic:\n    int& operator[] (int index);\n};\n\nint& IntList::operator[] (int index)\n{\n    return m_list[index];\n}\n```","id":"46f828121d9f3bf9","x":1882,"y":1880,"width":409,"height":348},
		{"type":"text","text":"### Overloading the subscript operator","id":"7b23c46389b812de","x":1860,"y":1800,"width":452,"height":50,"color":"5"},
		{"type":"text","text":"### Overloading the parenthesis operator","id":"f625bde200cf0e51","x":2440,"y":1800,"width":480,"height":50,"color":"5"},
		{"type":"text","text":"```cpp\n#include <cassert> // for assert()\n\nclass Matrix\n{\nprivate:\n    double m_data[4][4]{};\n\npublic:\n    double& operator()(int row, int col);\n    double operator()(int row, int col) const; // for const objects\n};\n\ndouble& Matrix::operator()(int row, int col)\n{\n    assert(col >= 0 && col < 4);\n    assert(row >= 0 && row < 4);\n\n    return m_data[row][col];\n}\n\ndouble Matrix::operator()(int row, int col) const\n{\n    assert(col >= 0 && col < 4);\n    assert(row >= 0 && row < 4);\n\n    return m_data[row][col];\n}\n```","id":"363c88517a537a4b","x":2440,"y":1885,"width":480,"height":686},
		{"type":"text","text":"Operator() is also commonly overloaded to implement **functors**","id":"129bf43e3d1480fb","x":2500,"y":2600,"width":360,"height":70},
		{"type":"text","text":"```cpp\n#include <iostream>\n\nclass Accumulator\n{\nprivate:\n    int m_counter{ 0 };\n\npublic:\n    int operator() (int i) { return (m_counter += i); }\n\n    void reset() { m_counter = 0; } // optional\n};\n\nint main()\n{\n    Accumulator acc{};\n    std::cout << acc(1) << '\\n'; // prints 1\n    std::cout << acc(3) << '\\n'; // prints 4\n\n    Accumulator acc2{};\n    std::cout << acc2(10) << '\\n'; // prints 10\n    std::cout << acc2(20) << '\\n'; // prints 30\n\n    return 0;\n}\n```","id":"ecabc3f8e547e80f","x":2397,"y":2700,"width":566,"height":600},
		{"type":"text","text":"### Overloading typecasts","id":"623d89ffa4fc8996","x":3143,"y":1800,"width":293,"height":50,"color":"5"},
		{"type":"text","text":"1. To overload the function that casts our class to an int, we use `operator int()` function.  Function must be non-static member.\n2. User-defined conversions do not have parameters, as there is no way to pass arguments explicitly to them. They do still have a hidden `*this` parameter, pointing to the implicit object (which is the object to be converted)\n3. The name of the conversion (e.g. int) is used as the return type, as it is the only return type allowed.","id":"b8c2c31075973e37","x":2960,"y":1885,"width":660,"height":215},
		{"type":"text","text":"```cpp\nclass Cents\n{\nprivate:\n    int m_cents;\npublic:\n    Cents(int cents=0): m_cents{ cents } {}\n\n    // Overloaded int cast\n    operator int() const { return m_cents; }\n\n    int getCents() const { return m_cents; }\n    void setCents(int cents) { m_cents = cents; }\n};\n```","id":"df1c7d92d07c2e10","x":3029,"y":2140,"width":523,"height":340},
		{"type":"text","text":"```cpp\nclass Dollars\n{\nprivate:\n    int m_dollars;\npublic:\n    Dollars(int dollars=0) \n    : m_dollars{ dollars }{}\n     // Allow us to convert Dollars into Cents\n     operator Cents() const\n      { return Cents{ m_dollars * 100 }; }\n};\n```","id":"eda5567f2ffdb92c","x":3029,"y":2504,"width":523,"height":316},
		{"type":"text","text":"CLASSES","id":"e8e169fa68123f0b","x":869,"y":-480,"width":250,"height":60,"color":"3"},
		{"type":"text","text":"### class constructors","id":"fc3f160946c6e943","x":2792,"y":105,"width":268,"height":56,"color":"6"},
		{"type":"text","text":"**elision**","id":"2324c5f6b836c4fd","x":3597,"y":660,"width":115,"height":56,"color":"6"},
		{"type":"text","text":"means that each member of the copy is initialized directly from the member of the class being copied.","id":"214f41aaa935735b","x":3742,"y":550,"width":477,"height":72},
		{"type":"text","text":"The process of omitting certain copy (or move) steps for performance purposes","id":"60b44d4b1a0518b5","x":3742,"y":650,"width":369,"height":77},
		{"type":"text","text":"```cpp\n// Copy constructor\n    Fraction(const Fraction& fraction) : m_numerator{fraction.m_numerator}, m_denominator{fraction.m_denominator}\n    { // no need to check for a denominator of 0 here since fraction must already be a valid Fraction\n    }\n```","id":"ef48307085c7de52","x":3981,"y":358,"width":761,"height":182},
		{"type":"text","text":"Classes that have custom destructors, copy/move constructors or copy/move assignment operators should deal exclusively with ownership of dynamic memory or resources. Other classes should not have custom destructors, copy/move constructors or copy/move assignment operators.","id":"ce52aa11325f88d8","x":3620,"y":225,"width":815,"height":115},
		{"type":"text","text":"### rule of three","id":"b5e386379b22a27e","x":3247,"y":14,"width":190,"height":57,"color":"4"},
		{"type":"text","text":"### rule of zero","id":"eb02729ea54965be","x":3942,"y":14,"width":170,"height":57,"color":"4"},
		{"type":"text","text":"if a class requires a user-defined destructor, copy constructor, or copy assignment operator, then it probably requires all three.","id":"def4afb4de3624b6","x":3481,"y":105,"width":501,"height":85},
		{"type":"text","text":"**copy constructor**","id":"1c70cfdec27bb065","x":3246,"y":417,"width":190,"height":62,"color":"5"},
		{"type":"text","text":"a special type of constructor used to create a new object as a copy of an existing object (of the same type).","id":"9411616c2ba3d5de","x":3461,"y":402,"width":465,"height":93},
		{"type":"text","text":"**Memberwise initialization**","id":"f45832aa8e1f4875","x":3462,"y":556,"width":250,"height":60,"color":"6"},
		{"type":"text","text":"converting constructors (conversion constructors)","id":"b698ee6d1417c82b","x":2440,"y":417,"width":240,"height":62,"color":"5"},
		{"type":"text","text":"Constructors eligible to be used for implicit conversions","id":"4d28d21f1dff5baf","x":2140,"y":409,"width":261,"height":78},
		{"type":"text","text":"`explicit` keyword","id":"52489861ebdcf44d","x":2168,"y":560,"width":206,"height":54,"color":"6"},
		{"type":"text","text":"Constructors and conversion functions made explicit will not be used for implicit conversions or copy initialization","id":"dc254f63788af307","x":1689,"y":542,"width":451,"height":91},
		{"type":"text","text":"`delete` keyword ","id":"1e8e4d7cb3537a34","x":2168,"y":690,"width":206,"height":50,"color":"6"},
		{"type":"text","text":"```cpp\nMyString(char) = delete; // any use of this constructor is an error\n```","id":"0b485267d8111b7b","x":1689,"y":678,"width":451,"height":74},
		{"type":"text","text":"Copy constructor and overloaded operators may also be deleted in order to prevent those functions from being used.","id":"f3d91cafd55264fc","x":1669,"y":780,"width":491,"height":80},
		{"type":"text","text":"### Overloading the assignment operator","id":"ec6c4477678d2e05","x":3720,"y":1800,"width":460,"height":50,"color":"5"},
		{"type":"text","text":"```cpp\nclass Fraction {\n// .. default fraction ...\npublic:\nFraction& operator= (const Fraction& fraction); }\n};\n// A simplistic implementation of operator= (see better implementation below)\nFraction& Fraction::operator= (const Fraction& fraction)\n{\n    // do the copy\n    m_numerator = fraction.m_numerator;\n    m_denominator = fraction.m_denominator;\n    // return the existing object so we can chain this operator\n    return *this;\n}\n```","id":"d55362f91e80305a","x":3628,"y":1900,"width":645,"height":400},
		{"type":"text","text":"**Detecting and handling self-assignment where an assignment operator needs to dynamically assign memory**","id":"4c3021db2ba7fb07","x":3695,"y":2340,"width":511,"height":71},
		{"type":"text","text":"```cpp\nif (this == &fraction)\nreturn *this;\n```","id":"46f36f9c215bc604","x":3739,"y":2435,"width":423,"height":69},
		{"type":"text","text":"**Copy initialization for classes**","id":"48873b2ac3b5a263","x":3184,"y":760,"width":315,"height":60,"color":"6"},
		{"type":"text","text":"Avoid using copy initialization, and use uniform initialization instead.","id":"80cbb9cdd82baf87","x":3532,"y":760,"width":545,"height":60,"color":"4"},
		{"type":"text","text":"memberwise copy (aka **shallow copy**)","id":"5207c4eada3525f4","x":4140,"y":760,"width":356,"height":60,"color":"6"},
		{"type":"text","text":"C++ copies each member of the class individually (using the assignment operator for overloaded operator=, and direct initialization for the copy constructor).","id":"ebb0bad3a1995730","x":4600,"y":750,"width":640,"height":80},
		{"id":"bfe974c397e8d8ae","type":"text","text":"doing a shallow copy on pointer values in a copy constructor or overloaded assignment operator is almost always asking for trouble.","x":4600,"y":639,"width":640,"height":88,"color":"1"},
		{"id":"a5121b47c7e94425","type":"text","text":"**deep copy**","x":5300,"y":658,"width":160,"height":50,"color":"6"},
		{"id":"331303b5ae71704d","type":"text","text":"allocates memory for the copy and then copies the actual value, so that the copy lives in distinct memory from the source","x":5500,"y":646,"width":504,"height":74}
	],
	"edges":[
		{"id":"06576004bfb6c9cb","fromNode":"97b22b9a51a2919e","fromSide":"right","toNode":"f7ed24461a77ca7a","toSide":"left","toEnd":"none","color":"6"},
		{"id":"e29b31b013c9564f","fromNode":"97b22b9a51a2919e","fromSide":"bottom","toNode":"dafcdf1957119d3e","toSide":"left","color":"4"},
		{"id":"d7426c644bf15488","fromNode":"dafcdf1957119d3e","fromSide":"right","toNode":"01791092d431cfc4","toSide":"left","color":"4"},
		{"id":"0323a68c04840b21","fromNode":"dafcdf1957119d3e","fromSide":"right","toNode":"d239e2b4cae28244","toSide":"left","color":"4"},
		{"id":"810eff4a2559baa8","fromNode":"97b22b9a51a2919e","fromSide":"bottom","toNode":"7abec560d938fc5d","toSide":"right","color":"1"},
		{"id":"18d560269f571848","fromNode":"7abec560d938fc5d","fromSide":"left","toNode":"f12f5446317af96f","toSide":"right","color":"4"},
		{"id":"4b3053aae9ff9512","fromNode":"7abec560d938fc5d","fromSide":"left","toNode":"a5e5f49f1bab64c9","toSide":"right","color":"4"},
		{"id":"f7617f8223610c15","fromNode":"7abec560d938fc5d","fromSide":"left","toNode":"732817837f00af83","toSide":"right","color":"4"},
		{"id":"b3cb18096233e94f","fromNode":"7abec560d938fc5d","fromSide":"left","toNode":"ca7ea9a1ffb21bf9","toSide":"right","color":"4"},
		{"id":"7626e0d03275e1ef","fromNode":"7abec560d938fc5d","fromSide":"left","toNode":"d9c026d9b81c44b3","toSide":"right","color":"4"},
		{"id":"de1142711e6ed764","fromNode":"4d4a47884473024a","fromSide":"bottom","toNode":"57ae7870b454b5c0","toSide":"top"},
		{"id":"43c59d6c3220874b","fromNode":"57ae7870b454b5c0","fromSide":"bottom","toNode":"d36f9f4374e62c90","toSide":"top"},
		{"id":"1095f3cd1e5b9e2b","fromNode":"d36f9f4374e62c90","fromSide":"bottom","toNode":"7fa8180929768602","toSide":"left"},
		{"id":"c8832047cf519ff1","fromNode":"4d4a47884473024a","fromSide":"bottom","toNode":"4de415e54b7b7d33","toSide":"top"},
		{"id":"494f65960060515b","fromNode":"4de415e54b7b7d33","fromSide":"bottom","toNode":"3ba6da8c16532ca6","toSide":"top"},
		{"id":"3b5ad3332b6adc0e","fromNode":"7fa8180929768602","fromSide":"top","toNode":"3ba6da8c16532ca6","toSide":"bottom"},
		{"id":"bde959269ae6e003","fromNode":"1bf3e677510ed023","fromSide":"bottom","toNode":"88381d6939418f2e","toSide":"top","toEnd":"none"},
		{"id":"faa954706f861943","fromNode":"4d4a47884473024a","fromSide":"bottom","toNode":"73099defc6dcb554","toSide":"top"},
		{"id":"26b9579522a1832d","fromNode":"73099defc6dcb554","fromSide":"bottom","toNode":"11781018a001f667","toSide":"top"},
		{"id":"20c3d5a8f12c3510","fromNode":"4deeebba46ad8d6c","fromSide":"top","toNode":"11781018a001f667","toSide":"bottom"},
		{"id":"e592dcc7225f771f","fromNode":"ad26f1daf2df2f2a","fromSide":"top","toNode":"7fa8180929768602","toSide":"bottom"},
		{"id":"496a7cf0dfef6a12","fromNode":"4deeebba46ad8d6c","fromSide":"bottom","toNode":"9023d77bf3e9d372","toSide":"top"},
		{"id":"907075486667a458","fromNode":"97b22b9a51a2919e","fromSide":"bottom","toNode":"4d4a47884473024a","toSide":"top"},
		{"id":"a24d52d0ef79a2e5","fromNode":"ad26f1daf2df2f2a","fromSide":"bottom","toNode":"1bf3e677510ed023","toSide":"top"},
		{"id":"54cb33ed39c0140a","fromNode":"ad26f1daf2df2f2a","fromSide":"bottom","toNode":"c7450d3a99642dd5","toSide":"top"},
		{"id":"cf5e9038f29dd657","fromNode":"c7450d3a99642dd5","fromSide":"bottom","toNode":"e1817b7cc4de2984","toSide":"top","toEnd":"none"},
		{"id":"6be65479ea719adb","fromNode":"bdbc5b6b2f0a123f","fromSide":"right","toNode":"c7450d3a99642dd5","toSide":"left"},
		{"id":"f03fe45baaf7d09f","fromNode":"bdbc5b6b2f0a123f","fromSide":"bottom","toNode":"a48a27d429b249f6","toSide":"top"},
		{"id":"e7f74179da84c74b","fromNode":"4deeebba46ad8d6c","fromSide":"bottom","toNode":"530c9e68b5d833aa","toSide":"top"},
		{"id":"42ea763f6a7ac85d","fromNode":"9023d77bf3e9d372","fromSide":"bottom","toNode":"083ed5f9817ca9eb","toSide":"top","toEnd":"none"},
		{"id":"1603858bcccfcdcf","fromNode":"530c9e68b5d833aa","fromSide":"bottom","toNode":"d0a23722dc15858e","toSide":"top"},
		{"id":"dae79c64f125c43b","fromNode":"d0a23722dc15858e","fromSide":"left","toNode":"083ed5f9817ca9eb","toSide":"right"},
		{"id":"be80c3b6ae9fc45f","fromNode":"d0a23722dc15858e","fromSide":"bottom","toNode":"b54a816907f36332","toSide":"top"},
		{"id":"773dcb2bd885d203","fromNode":"4deeebba46ad8d6c","fromSide":"bottom","toNode":"7b23c46389b812de","toSide":"top"},
		{"id":"60fb075899caa31b","fromNode":"7b23c46389b812de","fromSide":"bottom","toNode":"46f828121d9f3bf9","toSide":"top"},
		{"id":"7b559b92347cf1af","fromNode":"4deeebba46ad8d6c","fromSide":"bottom","toNode":"f625bde200cf0e51","toSide":"top"},
		{"id":"914775ce96555c46","fromNode":"f625bde200cf0e51","fromSide":"bottom","toNode":"363c88517a537a4b","toSide":"top"},
		{"id":"943629a43f6b8750","fromNode":"363c88517a537a4b","fromSide":"bottom","toNode":"129bf43e3d1480fb","toSide":"top"},
		{"id":"ac3cee6ade585850","fromNode":"129bf43e3d1480fb","fromSide":"bottom","toNode":"ecabc3f8e547e80f","toSide":"top"},
		{"id":"e0cc8e5dfe3724cf","fromNode":"4deeebba46ad8d6c","fromSide":"bottom","toNode":"623d89ffa4fc8996","toSide":"top"},
		{"id":"b06c658e8402c837","fromNode":"623d89ffa4fc8996","fromSide":"bottom","toNode":"b8c2c31075973e37","toSide":"top"},
		{"id":"7cea2402f67486a7","fromNode":"b8c2c31075973e37","fromSide":"bottom","toNode":"df1c7d92d07c2e10","toSide":"top"},
		{"id":"bbb70a03ae265ce1","fromNode":"df1c7d92d07c2e10","fromSide":"bottom","toNode":"eda5567f2ffdb92c","toSide":"top"},
		{"id":"ca17e175e0ccf27c","fromNode":"1c70cfdec27bb065","fromSide":"right","toNode":"9411616c2ba3d5de","toSide":"left","toEnd":"none"},
		{"id":"e3e2e591de60b764","fromNode":"1c70cfdec27bb065","fromSide":"bottom","toNode":"f45832aa8e1f4875","toSide":"left"},
		{"id":"aeb0ab6726245de6","fromNode":"f45832aa8e1f4875","fromSide":"right","toNode":"214f41aaa935735b","toSide":"left","toEnd":"none"},
		{"id":"a4932afc2bbeb300","fromNode":"9411616c2ba3d5de","fromSide":"right","toNode":"ef48307085c7de52","toSide":"left"},
		{"id":"d739f27f061ee787","fromNode":"1c70cfdec27bb065","fromSide":"bottom","toNode":"2324c5f6b836c4fd","toSide":"left"},
		{"id":"741954b9e0d354a1","fromNode":"2324c5f6b836c4fd","fromSide":"right","toNode":"60b44d4b1a0518b5","toSide":"left","toEnd":"none"},
		{"id":"54042eccd84ba8f5","fromNode":"b5e386379b22a27e","fromSide":"bottom","toNode":"1c70cfdec27bb065","toSide":"top"},
		{"id":"e1b2b612a27641ff","fromNode":"b5e386379b22a27e","fromSide":"bottom","toNode":"def4afb4de3624b6","toSide":"left","toEnd":"none"},
		{"id":"72935956cbb60bf5","fromNode":"eb02729ea54965be","fromSide":"left","toNode":"b5e386379b22a27e","toSide":"right","fromEnd":"arrow"},
		{"id":"2e252cd6e816ac9f","fromNode":"eb02729ea54965be","fromSide":"bottom","toNode":"ce52aa11325f88d8","toSide":"top","toEnd":"none"},
		{"id":"83d64e245125d0b2","fromNode":"1c70cfdec27bb065","fromSide":"bottom","toNode":"48873b2ac3b5a263","toSide":"top"},
		{"id":"d3b4a7a859e07cd3","fromNode":"e8e169fa68123f0b","fromSide":"bottom","toNode":"97b22b9a51a2919e","toSide":"top"},
		{"id":"024aad3a2216a48f","fromNode":"48873b2ac3b5a263","fromSide":"right","toNode":"80cbb9cdd82baf87","toSide":"left","toEnd":"none"},
		{"id":"79bfb9859790e42d","fromNode":"fc3f160946c6e943","fromSide":"bottom","toNode":"1c70cfdec27bb065","toSide":"top"},
		{"id":"016cb3461ceab438","fromNode":"e8e169fa68123f0b","fromSide":"bottom","toNode":"fc3f160946c6e943","toSide":"top"},
		{"id":"6c9e910ee4a37c82","fromNode":"fc3f160946c6e943","fromSide":"bottom","toNode":"b698ee6d1417c82b","toSide":"top"},
		{"id":"969a844d732d993b","fromNode":"b698ee6d1417c82b","fromSide":"left","toNode":"4d28d21f1dff5baf","toSide":"right","toEnd":"none"},
		{"id":"95c8e8c5a14f7597","fromNode":"b698ee6d1417c82b","fromSide":"bottom","toNode":"52489861ebdcf44d","toSide":"right"},
		{"id":"e44710331d8889d5","fromNode":"52489861ebdcf44d","fromSide":"left","toNode":"dc254f63788af307","toSide":"right","toEnd":"none"},
		{"id":"d7f5ccab74af9d4c","fromNode":"b698ee6d1417c82b","fromSide":"bottom","toNode":"1e8e4d7cb3537a34","toSide":"right"},
		{"id":"a5228412bcc23c48","fromNode":"1e8e4d7cb3537a34","fromSide":"left","toNode":"0b485267d8111b7b","toSide":"right"},
		{"id":"fa80c52687eca1ce","fromNode":"0b485267d8111b7b","fromSide":"bottom","toNode":"f3d91cafd55264fc","toSide":"top"},
		{"id":"5221b40494b23b3f","fromNode":"4deeebba46ad8d6c","fromSide":"bottom","toNode":"ec6c4477678d2e05","toSide":"top"},
		{"id":"434d3ecb9f221b93","fromNode":"ec6c4477678d2e05","fromSide":"bottom","toNode":"d55362f91e80305a","toSide":"top"},
		{"id":"cab5639523e8c727","fromNode":"d55362f91e80305a","fromSide":"bottom","toNode":"4c3021db2ba7fb07","toSide":"top"},
		{"id":"1f37942e365ef0b0","fromNode":"4c3021db2ba7fb07","fromSide":"bottom","toNode":"46f36f9c215bc604","toSide":"top"},
		{"id":"ad8c0bf9064fc1ab","fromNode":"214f41aaa935735b","fromSide":"right","toNode":"5207c4eada3525f4","toSide":"top"},
		{"id":"e7cc39df3ebe1634","fromNode":"5207c4eada3525f4","fromSide":"right","toNode":"ebb0bad3a1995730","toSide":"left","toEnd":"none"},
		{"id":"8befb12fca5e3638","fromNode":"5207c4eada3525f4","fromSide":"right","toNode":"bfe974c397e8d8ae","toSide":"left"},
		{"id":"bf3ff7bb65e6eb15","fromNode":"bfe974c397e8d8ae","fromSide":"right","toNode":"a5121b47c7e94425","toSide":"left","fromEnd":"arrow"},
		{"id":"e92f5d36f85f612a","fromNode":"a5121b47c7e94425","fromSide":"right","toNode":"331303b5ae71704d","toSide":"left","toEnd":"none"}
	]
}